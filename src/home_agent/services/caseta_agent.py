from __future__ import annotations

import asyncio
from typing import Any, Dict, Optional

from home_agent.bus.envelope import make_event
from home_agent.bus.mqtt_client import MqttClient
from home_agent.config import AppSettings
from home_agent.core.logging import configure_logging, get_logger


def _require_str(payload: Dict[str, Any], key: str) -> str:
    v = payload.get(key)
    if not isinstance(v, str) or not v.strip():
        raise ValueError("missing_or_invalid_%s" % key)
    return v


def _require_dict(payload: Dict[str, Any], key: str) -> Dict[str, Any]:
    v = payload.get(key)
    if not isinstance(v, dict):
        raise ValueError("missing_or_invalid_%s" % key)
    return v


async def run_caseta_agent() -> None:
    """
    Caséta bridge agent (LEAP).

    - Connects to the bridge via TLS using certs generated by `lap-pair`.
    - Publishes a device snapshot at startup.
    - Publishes a scenes snapshot at startup (Caséta scenes are virtual buttons).
    - Listens for MQTT commands and executes them (on/off/level/scene).

    MQTT command topic:  <base>/lutron/command
    Expected envelope:
      - type: lutron.command
      - data:
          - action: "on"|"off"|"level"|"scene"
          - device_id: <int|str> (for on/off/level)
          - level: 0-100 (for level)
          - scene_id: <int|str> (for scene)
          - scene_name: <str> (for scene; resolved to scene_id when possible)
    """
    settings = AppSettings()
    configure_logging(settings.log_level)
    log = get_logger(service="caseta_agent")

    if not settings.caseta.enabled:
        log.warning("caseta_disabled", hint="Set CASETA_ENABLED=true to run this service")
        return

    if not settings.caseta.host:
        log.error("missing_config", key="CASETA_HOST")
        return
    if not (settings.caseta.ca_cert_path and settings.caseta.cert_path and settings.caseta.key_path):
        log.error("missing_config", key="CASETA_*_PATH", hint="Run lap-pair and set cert/key paths")
        return

    try:
        from pylutron_caseta.smartbridge import Smartbridge  # type: ignore
    except Exception as e:  # pragma: no cover
        raise RuntimeError("pylutron-caseta not installed. Run: pip install -e '.[caseta]'") from e

    bridge = Smartbridge.create_tls(
        settings.caseta.host,
        settings.caseta.key_path,
        settings.caseta.cert_path,
        settings.caseta.ca_cert_path,
        port=int(settings.caseta.port),
    )
    await bridge.connect()
    log.info("caseta_connected", host=settings.caseta.host, port=settings.caseta.port)

    mqttc = MqttClient(
        host=settings.mqtt.host,
        port=settings.mqtt.port,
        username=settings.mqtt.username,
        password=settings.mqtt.password,
        client_id="homeagent-caseta-agent",
    )
    await mqttc.connect()

    base = settings.mqtt.base_topic
    cmd_topic = f"{base}/lutron/command"
    evt_topic = f"{base}/lutron/event"
    mqttc.subscribe(cmd_topic)
    log.info("subscribed", topic=cmd_topic)

    # Publish devices snapshot (best-effort).
    try:
        devices = list(getattr(bridge, "devices", {}).values())
        snapshot = make_event(source="caseta-agent", typ="lutron.devices", data={"count": len(devices), "devices": devices})
        mqttc.publish_json(evt_topic, snapshot, retain=True)
        log.info("devices_published", count=len(devices))
    except Exception:
        log.warning("devices_publish_failed")

    # Publish scenes snapshot (best-effort).
    try:
        scenes = list(getattr(bridge, "scenes", {}).values())
        snap = make_event(source="caseta-agent", typ="lutron.scenes", data={"count": len(scenes), "scenes": scenes})
        mqttc.publish_json(evt_topic, snap, retain=True)
        log.info("scenes_published", count=len(scenes))
    except Exception:
        log.warning("scenes_publish_failed")

    def _scene_id_by_name(name: str) -> Optional[str]:
        want = (name or "").strip().lower()
        if not want:
            return None
        for s in (getattr(bridge, "scenes", {}) or {}).values():
            if not isinstance(s, dict):
                continue
            sid = s.get("scene_id")
            nm = s.get("name")
            if isinstance(nm, str) and nm.strip().lower() == want:
                if isinstance(sid, (str, int)) and str(sid).strip():
                    return str(sid).strip()
        return None

    async def _handle_command(data: Dict[str, Any], trace_id: str) -> None:
        action = data.get("action")
        if action == "scene":
            scene_id = data.get("scene_id")
            scene_name = data.get("scene_name")
            if isinstance(scene_id, int):
                scene_id = str(scene_id)
            if isinstance(scene_id, str):
                scene_id = scene_id.strip()
            if (not isinstance(scene_id, str) or not scene_id) and isinstance(scene_name, str):
                scene_id = _scene_id_by_name(scene_name)
            if not isinstance(scene_id, str) or not scene_id:
                raise ValueError("missing_or_invalid_scene_id")

            await bridge.activate_scene(scene_id)
            ack_data: Dict[str, Any] = {"action": action, "scene_id": scene_id}
            if isinstance(scene_name, str) and scene_name.strip():
                ack_data["scene_name"] = scene_name.strip()
        else:
            device_id = data.get("device_id")
            # pylutron-caseta expects device_id as a string key into bridge.devices
            if isinstance(device_id, int):
                device_id = str(device_id)
            elif isinstance(device_id, str):
                device_id = device_id.strip()
            if not isinstance(device_id, str) or not device_id:
                raise ValueError("missing_or_invalid_device_id")

            if action == "on":
                await bridge.turn_on(device_id)
            elif action == "off":
                await bridge.turn_off(device_id)
            elif action == "level":
                level = data.get("level")
                if isinstance(level, str) and level.isdigit():
                    level = int(level)
                if not isinstance(level, int):
                    raise ValueError("missing_or_invalid_level")
                level = max(0, min(100, int(level)))
                await bridge.set_value(device_id, level)
            else:
                raise ValueError("unknown_action")
            ack_data = {"device_id": device_id, "action": action}

        ack = make_event(source="caseta-agent", typ="lutron.command.ack", trace_id=trace_id, data=ack_data)
        mqttc.publish_json(evt_topic, ack)

    try:
        while True:
            msg = await mqttc.next_message()
            try:
                payload: Dict[str, Any] = msg.json()
                _require_str(payload, "id")
                _require_str(payload, "ts")
                _require_str(payload, "source")
                typ = _require_str(payload, "type")
                trace_id = _require_str(payload, "trace_id")
                data = _require_dict(payload, "data")
            except Exception as e:
                log.warning("bad_event", topic=msg.topic, error=str(e))
                continue

            if typ != "lutron.command":
                log.warning("unexpected_type", type=typ)
                continue

            try:
                await _handle_command(data, trace_id)
                log.info("command_ok", action=data.get("action"), device_id=data.get("device_id"))
            except Exception as e:
                err = make_event(
                    source="caseta-agent",
                    typ="lutron.command.error",
                    trace_id=trace_id,
                    data={"error": str(e), "data": data},
                )
                mqttc.publish_json(evt_topic, err)
                log.warning("command_failed", error=str(e))
    finally:
        await mqttc.close()
        try:
            await bridge.close()
        except Exception:
            pass


def main() -> int:
    asyncio.run(run_caseta_agent())
    return 0

