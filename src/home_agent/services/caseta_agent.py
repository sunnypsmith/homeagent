from __future__ import annotations

import asyncio
from typing import Any, Dict, Optional

from home_agent.bus.envelope import make_event
from home_agent.bus.mqtt_client import MqttClient
from home_agent.config import AppSettings
from home_agent.core.logging import configure_logging, get_logger


def _require_str(payload: Dict[str, Any], key: str) -> str:
    v = payload.get(key)
    if not isinstance(v, str) or not v.strip():
        raise ValueError("missing_or_invalid_%s" % key)
    return v


def _require_dict(payload: Dict[str, Any], key: str) -> Dict[str, Any]:
    v = payload.get(key)
    if not isinstance(v, dict):
        raise ValueError("missing_or_invalid_%s" % key)
    return v


async def run_caseta_agent() -> None:
    """
    Cas√©ta bridge agent (LEAP).

    - Connects to the bridge via TLS using certs generated by `lap-pair`.
    - Publishes a device snapshot at startup.
    - Listens for MQTT commands and executes them (on/off/level).

    MQTT command topic:  <base>/lutron/command
    Expected envelope:
      - type: lutron.command
      - data: { action: "on"|"off"|"level", device_id: <int>, level?: 0-100 }
    """
    settings = AppSettings()
    configure_logging(settings.log_level)
    log = get_logger(service="caseta_agent")

    if not settings.caseta.enabled:
        log.warning("caseta_disabled", hint="Set CASETA_ENABLED=true to run this service")
        return

    if not settings.caseta.host:
        log.error("missing_config", key="CASETA_HOST")
        return
    if not (settings.caseta.ca_cert_path and settings.caseta.cert_path and settings.caseta.key_path):
        log.error("missing_config", key="CASETA_*_PATH", hint="Run lap-pair and set cert/key paths")
        return

    try:
        from pylutron_caseta.smartbridge import Smartbridge  # type: ignore
    except Exception as e:  # pragma: no cover
        raise RuntimeError("pylutron-caseta not installed. Run: pip install -e '.[caseta]'") from e

    bridge = Smartbridge.create_tls(
        settings.caseta.host,
        settings.caseta.key_path,
        settings.caseta.cert_path,
        settings.caseta.ca_cert_path,
        port=int(settings.caseta.port),
    )
    await bridge.connect()
    log.info("caseta_connected", host=settings.caseta.host, port=settings.caseta.port)

    mqttc = MqttClient(
        host=settings.mqtt.host,
        port=settings.mqtt.port,
        username=settings.mqtt.username,
        password=settings.mqtt.password,
        client_id="homeagent-caseta-agent",
    )
    await mqttc.connect()

    base = settings.mqtt.base_topic
    cmd_topic = f"{base}/lutron/command"
    evt_topic = f"{base}/lutron/event"
    mqttc.subscribe(cmd_topic)
    log.info("subscribed", topic=cmd_topic)

    # Publish devices snapshot (best-effort).
    try:
        devices = list(getattr(bridge, "devices", {}).values())
        # Normalize devices to plain dicts (they are already dict-like in pylutron-caseta).
        snapshot = make_event(
            source="caseta-agent",
            typ="lutron.devices",
            data={"count": len(devices), "devices": devices},
        )
        mqttc.publish_json(evt_topic, snapshot, retain=True)
        log.info("devices_published", count=len(devices))
    except Exception:
        log.warning("devices_publish_failed")

    async def _handle_command(data: Dict[str, Any], trace_id: str) -> None:
        action = data.get("action")
        device_id = data.get("device_id")
        # pylutron-caseta expects device_id as a string key into bridge.devices
        if isinstance(device_id, int):
            device_id = str(device_id)
        elif isinstance(device_id, str):
            device_id = device_id.strip()
        if not isinstance(device_id, str) or not device_id:
            raise ValueError("missing_or_invalid_device_id")

        if action == "on":
            await bridge.turn_on(device_id)
        elif action == "off":
            await bridge.turn_off(device_id)
        elif action == "level":
            level = data.get("level")
            if isinstance(level, str) and level.isdigit():
                level = int(level)
            if not isinstance(level, int):
                raise ValueError("missing_or_invalid_level")
            level = max(0, min(100, int(level)))
            await bridge.set_value(device_id, level)
        else:
            raise ValueError("unknown_action")

        ack = make_event(
            source="caseta-agent",
            typ="lutron.command.ack",
            trace_id=trace_id,
            data={"device_id": device_id, "action": action},
        )
        mqttc.publish_json(evt_topic, ack)

    try:
        while True:
            msg = await mqttc.next_message()
            try:
                payload: Dict[str, Any] = msg.json()
                _require_str(payload, "id")
                _require_str(payload, "ts")
                _require_str(payload, "source")
                typ = _require_str(payload, "type")
                trace_id = _require_str(payload, "trace_id")
                data = _require_dict(payload, "data")
            except Exception as e:
                log.warning("bad_event", topic=msg.topic, error=str(e))
                continue

            if typ != "lutron.command":
                log.warning("unexpected_type", type=typ)
                continue

            try:
                await _handle_command(data, trace_id)
                log.info("command_ok", action=data.get("action"), device_id=data.get("device_id"))
            except Exception as e:
                err = make_event(
                    source="caseta-agent",
                    typ="lutron.command.error",
                    trace_id=trace_id,
                    data={"error": str(e), "data": data},
                )
                mqttc.publish_json(evt_topic, err)
                log.warning("command_failed", error=str(e))
    finally:
        await mqttc.close()
        try:
            await bridge.close()
        except Exception:
            pass


def main() -> int:
    asyncio.run(run_caseta_agent())
    return 0

